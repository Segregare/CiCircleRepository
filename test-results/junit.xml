<?xml version="1.0" encoding="utf-8"?><testsuite errors="0" failures="1" name="pytest" skips="0" tests="1" time="0.190"><testcase classname="tests.test_Class" file="tests/test_Class.py" line="5" name="test_first_test" time="0.004570484161376953"><failure message="selenium.common.exceptions.WebDriverException: Message: &apos;chromedriver&apos; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home">self = &lt;selenium.webdriver.chrome.service.Service object at 0x7f59f645b9b0&gt;

    def start(self):
        &quot;&quot;&quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&apos;t start the service
               or when it can&apos;t connect to the service
            &quot;&quot;&quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &apos;Windows&apos;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
&gt;                                           stdin=PIPE)

venv/lib/python3.6/site-packages/selenium/webdriver/common/service.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;subprocess.Popen object at 0x7f59f645be80&gt;, args = [&apos;../chromedriver&apos;, &apos;--port=59739&apos;], bufsize = -1, executable = None, stdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = True, shell = False, cwd = None
env = environ({&apos;CLUTTER_IM_MODULE&apos;: &apos;xim&apos;, &apos;LS_COLORS&apos;: &apos;rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01...yakov/PycharmProjects/CircleCi/venv/bin/pytest&apos;, &apos;PYTEST_CURRENT_TEST&apos;: &apos;tests/test_Class.py::test_first_test (call)&apos;})
universal_newlines = False, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False, pass_fds = ()

    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,
                 shell=False, cwd=None, env=None, universal_newlines=False,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=(), *, encoding=None, errors=None):
        &quot;&quot;&quot;Create new Popen instance.&quot;&quot;&quot;
        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()
    
        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError(&quot;bufsize must be an integer&quot;)
    
        if _mswindows:
            if preexec_fn is not None:
                raise ValueError(&quot;preexec_fn is not supported on Windows &quot;
                                 &quot;platforms&quot;)
            any_stdio_set = (stdin is not None or stdout is not None or
                             stderr is not None)
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                if any_stdio_set:
                    close_fds = False
                else:
                    close_fds = True
            elif close_fds and any_stdio_set:
                raise ValueError(
                        &quot;close_fds is not supported on Windows platforms&quot;
                        &quot; if you redirect stdin/stdout/stderr&quot;)
        else:
            # POSIX
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                close_fds = True
            if pass_fds and not close_fds:
                warnings.warn(&quot;pass_fds overriding close_fds.&quot;, RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError(&quot;startupinfo is only supported on Windows &quot;
                                 &quot;platforms&quot;)
            if creationflags != 0:
                raise ValueError(&quot;creationflags is only supported on Windows &quot;
                                 &quot;platforms&quot;)
    
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.universal_newlines = universal_newlines
        self.encoding = encoding
        self.errors = errors
    
        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin---&gt;  p2cread
        # c2pread    &lt;--stdout---  c2pwrite
        # errread    &lt;--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    
        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).
    
        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)
    
        text_mode = encoding or errors or universal_newlines
    
        self._closed_child_pipe_fds = False
    
        try:
            if p2cwrite != -1:
                self.stdin = io.open(p2cwrite, &apos;wb&apos;, bufsize)
                if text_mode:
                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                            line_buffering=(bufsize == 1),
                            encoding=encoding, errors=errors)
            if c2pread != -1:
                self.stdout = io.open(c2pread, &apos;rb&apos;, bufsize)
                if text_mode:
                    self.stdout = io.TextIOWrapper(self.stdout,
                            encoding=encoding, errors=errors)
            if errread != -1:
                self.stderr = io.open(errread, &apos;rb&apos;, bufsize)
                if text_mode:
                    self.stderr = io.TextIOWrapper(self.stderr,
                            encoding=encoding, errors=errors)
    
            self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
&gt;                               restore_signals, start_new_session)

/usr/lib/python3.6/subprocess.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;subprocess.Popen object at 0x7f59f645be80&gt;, args = [&apos;../chromedriver&apos;, &apos;--port=59739&apos;], executable = b&apos;../chromedriver&apos;, preexec_fn = None, close_fds = True, pass_fds = (), cwd = None
env = environ({&apos;CLUTTER_IM_MODULE&apos;: &apos;xim&apos;, &apos;LS_COLORS&apos;: &apos;rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01...yakov/PycharmProjects/CircleCi/venv/bin/pytest&apos;, &apos;PYTEST_CURRENT_TEST&apos;: &apos;tests/test_Class.py::test_first_test (call)&apos;})
startupinfo = None, creationflags = 0, shell = False, p2cread = 8, p2cwrite = 10, c2pread = -1, c2pwrite = 11, errread = -1, errwrite = 11, restore_signals = True, start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals, start_new_session):
        &quot;&quot;&quot;Execute program (POSIX version)&quot;&quot;&quot;
    
        if isinstance(args, (str, bytes)):
            args = [args]
        else:
            args = list(args)
    
        if shell:
            args = [&quot;/bin/sh&quot;, &quot;-c&quot;] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: &quot;exception name:hex errno:description&quot;
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write &lt; 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b&apos;=&apos; in k:
                            raise ValueError(&quot;illegal environment variable name&quot;)
                        env_list.append(k + b&apos;=&apos; + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session, preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            # self._devnull is not always defined.
            devnull_fd = getattr(self, &apos;_devnull&apos;, None)
            if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                os.close(p2cread)
            if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                os.close(c2pwrite)
            if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                os.close(errwrite)
            if devnull_fd is not None:
                os.close(devnull_fd)
            # Prevent a double close of these fds from __init__ on error.
            self._closed_child_pipe_fds = True
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) &gt; 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b&apos;:&apos;, 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b&apos;SubprocessError&apos;
                hex_errno = b&apos;0&apos;
                err_msg = &apos;Bad exception data from child: {!r}&apos;.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode(&apos;ascii&apos;),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == &quot;noexec&quot;)
                if child_exec_never_called:
                    err_msg = &quot;&quot;
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
                    if errno_num == errno.ENOENT:
                        err_msg += &apos;: &apos; + repr(err_filename)
&gt;               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: &apos;../chromedriver&apos;: &apos;../chromedriver&apos;

/usr/lib/python3.6/subprocess.py:1364: FileNotFoundError

During handling of the above exception, another exception occurred:

    def test_first_test():
&gt;       browser = webdriver.Chrome(executable_path=&apos;../chromedriver&apos;)

tests/test_Class.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.6/site-packages/selenium/webdriver/chrome/webdriver.py:73: in __init__
    self.service.start()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;selenium.webdriver.chrome.service.Service object at 0x7f59f645b9b0&gt;

    def start(self):
        &quot;&quot;&quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&apos;t start the service
               or when it can&apos;t connect to the service
            &quot;&quot;&quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &apos;Windows&apos;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)
        except TypeError:
            raise
        except OSError as err:
            if err.errno == errno.ENOENT:
                raise WebDriverException(
                    &quot;&apos;%s&apos; executable needs to be in PATH. %s&quot; % (
&gt;                       os.path.basename(self.path), self.start_error_message)
E                       selenium.common.exceptions.WebDriverException: Message: &apos;chromedriver&apos; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home

venv/lib/python3.6/site-packages/selenium/webdriver/common/service.py:83: WebDriverException</failure></testcase></testsuite>